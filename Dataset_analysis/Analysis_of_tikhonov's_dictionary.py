# -*- coding: utf-8 -*-
"""Analysis of Tikhonov's dictionary.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J07Co3bAiSPJnIS7NS49xYL1Qtj_mE4W
"""

# Загрузка необходимых библиотек
import pandas as pd
from pymystem3 import Mystem
import plotly.graph_objects as go
import plotly.express as px
import matplotlib.pyplot as plt
from sklearn.preprocessing import LabelEncoder

# Чтение данных из файла txt
df = pd.read_csv('/content/tikhonov-clean.txt', sep='\t', header=None, names=['lemma', 'morphemic_structure'])
# Добавление нового столбца 'author' со значением 'КЕ'
df['author'] = 'T'

# Вывод датасета
df.head()

df.info()

# Сохранение файла в новом формате
df.to_csv('tikhonov.csv')

df = pd.read_csv('/content/tikhonov - tikhonov.csv')
df.head()

# Вывод строк, где ть - END
df.loc[df['morphemic_structure'].str.contains('/ть:END')]

# Вывод строк, в которых нет END
df.loc[~df['morphemic_structure'].str.endswith('END')]

# Разметка частей речи по данным датасета Морфемного словаря русского языка
df['pos_ke'] = None

# Загрузка датасета
ke = pd.read_csv('/content/morphemic_structure_KE_good.csv')

# Создание словаря с использованием столбцов 'lemma' и 'pos' из датасета ke
ke_lemma_dict = ke[['lemma', 'pos']].set_index('lemma')['pos'].to_dict()

# Функция для заполнения столбца 'pos_ke' в датасете df с использованием значений из словаря ke_lemma_dict
def fill_pos(row):
    lemma = row['lemma']
    if lemma in ke_lemma_dict:
        return ke_lemma_dict[lemma]
    else:
        return 'unknown'

# Применение функции fill_pos к каждой строке датасета df и сохранение результатов в новый столбец 'pos_ke'
df['pos_ke'] = df.apply(fill_pos, axis=1)

# Проверка
df.head()

df['pos_ke'].value_counts()

df_good = df.query('pos_ke != "unknown"')

df_good.to_csv('tikhonov_pos_ke_good.csv')

df_bad = df.query('pos_ke == "unknown"')

# Создаем столбец с частеречной разметкой, используя Mystem
# Экземпляр Mystem
m = Mystem()

# Список слов датасета
word_list = df_bad['lemma'].tolist()

# Список для хранения частей речи
pos_list = []

# Проходим по каждому слову в списке и определяем его часть речи с помощью Mystem
for word in word_list:
    try:
        analysis = m.analyze(word)
        if analysis and 'analysis' in analysis[0]:
            pos_tag = analysis[0]['analysis'][0]['gr'].split(',')[0].split('=')[0]
            pos_list.append(pos_tag)
        else:
            pos_list.append('UNKNOWN')  # Если Mystem не смог определить часть речи, помечаем как UNKNOWN
    except IndexError:
        pos_list.append('UNKNOWN')  # Обрабатываем ошибку IndexError и помечаем слово как UNKNOWN

# Создание нового столбца 'pos_mystem' и добавление в него части речи
df_bad['pos_mystem'] = pos_list

# Проверка
df_bad.head(10)

df_bad['pos_mystem'].value_counts()

df_bad.query('pos_mystem == "UNKNOWN"')

# Замена значений
df_bad.loc[(df_bad['lemma'] == "ши"), 'pos_mystem'] = 'S'
df_bad.loc[(df_bad['lemma'] == "нелюбый"), 'pos_mystem'] = 'A'

# Проверка
df_bad.query('pos_mystem == "UNKNOWN"')

# Проверка данных с учетом морфем
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/ый:END'))]['pos_mystem'].value_counts()

# Внесение исправлений
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/ый:END')) & (df_bad['pos_mystem'] == "V"), 'pos_mystem'] = 'A'
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/ый:END')) & (df_bad['pos_mystem'] == "ADV"), 'pos_mystem'] = 'A'
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/ый:END')) & (df_bad['pos_mystem'] == "S"), 'pos_mystem'] = 'A'
df_bad.loc[(df_bad['lemma'] == "габионный"), 'pos_mystem'] = 'A'
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/ый:END')) & (df_bad['pos_mystem'] == "ANUM"), 'pos_mystem'] = 'ANUM'
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/ый:END')) & (df_bad['pos_mystem'] == "COM"), 'pos_mystem'] = 'A'
df_bad.loc[(df_bad['lemma'] == "один-единственный"), 'pos_mystem'] = 'A'
df_bad.loc[(df_bad['lemma'] == "один-разъединственный"), 'pos_mystem'] = 'A'
df_bad.loc[(df_bad['lemma'] == "до-диезный"), 'pos_mystem'] = 'A'

# Проверка
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/ый:END'))]['pos_mystem'].value_counts()

# Проверка данных с учетом морфем
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/ий:END'))]['pos_mystem'].value_counts()

# Внесение исправлений
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/ий:END')) & (df_bad['pos_mystem'] == "V"), 'pos_mystem'] = 'A'
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/ий:END')) & (df_bad['pos_mystem'] == "S"), 'pos_mystem'] = 'A'
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/ий:END')) & (df_bad['pos_mystem'] == "ADV"), 'pos_mystem'] = 'A'
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/ий:END')) & (df_bad['pos_mystem'] == "COM"), 'pos_mystem'] = 'A'

# Проверка
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/ий:END'))]['pos_mystem'].value_counts()

# Проверка данных с учетом морфем
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/ой:END'))]['pos_mystem'].value_counts()

# Внесение исправлений
df_bad.loc[(df_bad['lemma'] == "день-другой"), 'pos_mystem'] = 'ADV'
df_bad.loc[(df_bad['lemma'] == "блатной"), 'pos_mystem'] = 'A,S'
df_bad.loc[(df_bad['lemma'] == "костровой"), 'pos_mystem'] = 'A,S'
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/ой:END')) & (df_bad['pos_mystem'] == "S"), 'pos_mystem'] = 'A'
df_bad.loc[(df_bad['lemma'] == "день-деньской"), 'pos_mystem'] = 'ADV'
df_bad.loc[(df_bad['lemma'] == "обыденкой"), 'pos_mystem'] = 'ADV'
df_bad.loc[(df_bad['lemma'] == "сам-восьмой"), 'pos_mystem'] = 'ANUM'
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/ой:END')) & (df_bad['pos_mystem'] == "ADV"), 'pos_mystem'] = 'A'
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/ой:END')) & (df_bad['pos_mystem'] == "COM"), 'pos_mystem'] = 'A'

# Проверка
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/ой:END'))]['pos_mystem'].value_counts()

# Проверка данных с учетом морфем
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/о:END'))]['pos_mystem'].value_counts()

# Внесение исправлений
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/о:END')) & (df_bad['pos_mystem'] == "A"), 'pos_mystem'] = 'ADV'
# Следует исправить окончания на суффиксы
df_bad.loc[(df_bad['lemma'] == "пилено-перепилено"), 'pos_mystem'] = 'A'
df_bad.loc[(df_bad['lemma'] == "читано-перечитано"), 'pos_mystem'] = 'A'
df_bad.loc[(df_bad['lemma'] == "штопано-перештопано"), 'pos_mystem'] = 'A'
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/о:END')) & (df_bad['pos_mystem'] == "V"), 'pos_mystem'] = 'S'
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/о:END')) & (df_bad['pos_mystem'] == "COM"), 'pos_mystem'] = 'S'

# Проверка
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/о:END'))]['pos_mystem'].value_counts()

# Проверка данных с учетом морфем
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/о:SUFF'))]['pos_mystem'].value_counts()

# Внесение исправлений
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/о:SUFF')) & (df_bad['pos_mystem'] == "A"), 'pos_mystem'] = 'ADV'

# Проверка
df_bad.loc[(df_bad['morphemic_structure'].str.endswith('/о:SUFF'))]['pos_mystem'].value_counts()

df_bad.to_csv('tikhonov_part_bad.csv')

ti = pd.read_csv('/content/tikhonov_part_bad - tikhonov_part_bad (1).csv')

ti.head()

# Проверка данных
ti.loc[(ti['lemma'].str.endswith('ийся')) & (ti['pos_mystem'] == "V")]

# Внесение исправлений
ti.loc[(ti['lemma'].str.endswith('ийся')) & (ti['pos_mystem'] == "V"), 'pos_mystem'] = 'A'

# Проверка
ti.loc[(ti['lemma'].str.endswith('ийся'))]['pos_mystem'].value_counts()

ti.loc[(ti['lemma'].str.endswith('ийся')) & (ti['pos_mystem'] == "S")]

ti.loc[(ti['lemma'].str.endswith('ийся')) & (ti['pos_mystem'] == "S"), 'pos_mystem'] = 'S,A'

ti.loc[(ti['morphemic_structure'].str.endswith('/а:END'))]

ti.loc[(ti['morphemic_structure'].str.endswith('/а:END'))]['pos_mystem'].value_counts()

ti.loc[(ti['morphemic_structure'].str.endswith('/а:END'))&(ti['pos_mystem'] == 'A')]

ti.loc[(ti['lemma'] == "вполоткрыта"), 'pos_mystem'] = 'ADV'
ti.loc[(ti['lemma'] == "вполпряма"), 'pos_mystem'] = 'ADV'
ti.loc[(ti['lemma'] == "допряма"), 'pos_mystem'] = 'ADV'
ti.loc[(ti['lemma'] == "досветла"), 'pos_mystem'] = 'ADV'
ti.loc[(ti['lemma'] == "досветла"), 'pos_mystem'] = 'ADV'
ti.loc[(ti['morphemic_structure'].str.endswith('/а:END'))&(ti['pos_mystem'] == 'A'), 'pos_mystem'] = 'S'
ti.loc[(ti['lemma'] == "мала"), 'pos_mystem'] = 'A'
ti.loc[(ti['lemma'] == "рада"), 'pos_mystem'] = 'S,A'
ti.loc[(ti['lemma'] == "стемна"), 'pos_mystem'] = 'A'
ti.loc[(ti['lemma'] == "экстра"), 'pos_mystem'] = 'A'
ti.loc[(ti['lemma'] == "лазка"), 'pos_mystem'] = 'S'
ti.loc[(ti['lemma'] == "лежа"), 'pos_mystem'] = 'ADV'
ti.loc[(ti['morphemic_structure'].str.endswith('/а:END'))&(ti['pos_mystem'] == 'V'), 'pos_mystem'] = 'S'

ti.loc[(ti['morphemic_structure'].str.endswith('/а:END'))]['pos_mystem'].value_counts()

ti.loc[(ti['morphemic_structure'].str.endswith('/я:END'))]['pos_mystem'].value_counts()

ti.loc[(ti['morphemic_structure'].str.endswith('/я:END'))&(ti['pos_mystem'] == 'V'), 'pos_mystem'] = 'ADV'

# Проверка
ti.loc[(ti['morphemic_structure'].str.endswith('/я:END'))]['pos_mystem'].value_counts()

ti.loc[(ti['morphemic_structure'].str.endswith('/ть:END/ся:POST'))]['pos_mystem'].value_counts()

# Замена
ti.loc[(ti['morphemic_structure'].str.endswith('/ть:END/ся:POST'))&(ti['pos_mystem'] == "S"), 'pos_mystem'] = 'V'

# Проверка
ti.loc[(ti['morphemic_structure'].str.endswith('/у:SUFF'))]['pos_mystem'].value_counts()

# Замена
ti.loc[(ti['morphemic_structure'].str.endswith('/у:SUFF'))&(ti['pos_mystem'] == "S"), 'pos_mystem'] = 'ADV'

ti.loc[(ti['morphemic_structure'].str.endswith('ROOT'))]['pos_mystem'].value_counts()

# Замена
ti.loc[(ti['morphemic_structure'].str.endswith('ROOT'))&(ti['pos_mystem'] == "V"), 'pos_mystem'] = 'S'
ti.loc[(ti['lemma'] == "брутто-вес"), 'pos_mystem'] = 'S'
ti.loc[(ti['lemma'] == "короткоголов"), 'pos_mystem'] = 'S'
ti.loc[(ti['lemma'] == "короткохвост"), 'pos_mystem'] = 'S'
ti.loc[(ti['lemma'] == "нетто-вес"), 'pos_mystem'] = 'S'
ti.loc[(ti['lemma'] == "рабочий-специалист"), 'pos_mystem'] = 'S'
ti.loc[(ti['lemma'] == "танин"), 'pos_mystem'] = 'S'
ti.loc[(ti['lemma'] == "толстотел"), 'pos_mystem'] = 'S'
ti.loc[(ti['lemma'] == "тупей"), 'pos_mystem'] = 'S'
ti.loc[(ti['lemma'] == "брутто-задолженность"), 'pos_mystem'] = 'S'

ti.loc[(ti['morphemic_structure'].str.endswith('/ть:END'))]['pos_mystem'].value_counts()

ti.loc[(ti['morphemic_structure'].str.endswith('/ть:END'))&(ti['pos_mystem'] == 'S'), 'pos_mystem'] = 'V'

ti.to_csv('tikhonov_pos_finish.csv')

import pandas as pd

# Загрузка датасетов
ti_1 = pd.read_csv('/content/tikhonov_pos_ke_good - all.csv')
ti_2 = pd.read_csv('/content/tikhonov_pos_finish - all.csv')

# Объединение датасетов
ti = pd.concat([ti_1, ti_2], ignore_index=True)

# Проверка
ti.info()

ti['pos'].value_counts()

ti.to_csv('tikhonov_good.csv')

ti = pd.read_csv('/content/tikhonov_good - tikhonov_good (3).csv')
ti.head()

ti.loc[ti['lemma'].str.endswith('чься')&(ti['pos'] == "V")]

# Добавление нулевых окончаний
ti.loc[(ti['pos'] == 'S') & (~ti['morphemic_structure'].str.endswith('END')), 'morphemic_structure'] += '/Ø:END'
ti.loc[(ti['pos'] == 'A') & (~ti['morphemic_structure'].str.endswith('END')) & (~ti['morphemic_structure'].str.endswith('POST')), 'morphemic_structure'] += '/Ø:END'
ti.loc[(ti['pos'] == 'NUM') & (~ti['morphemic_structure'].str.endswith('END')), 'morphemic_structure'] += '/Ø:END'
ti.loc[(ti['pos'] == 'APRO') & (~ti['morphemic_structure'].str.endswith('END')), 'morphemic_structure'] += '/Ø:END'
ti.loc[(ti['pos'] == 'A,S') & (~ti['morphemic_structure'].str.endswith('END')), 'morphemic_structure'] += '/Ø:END'
ti.loc[(ti['pos'] == 'NUM,S') & (~ti['morphemic_structure'].str.endswith('END')), 'morphemic_structure'] += '/Ø:END'
ti.loc[(ti['pos'] == 'APRO,SPRO') & (~ti['morphemic_structure'].str.endswith('END')), 'morphemic_structure'] += '/Ø:END'
ti.loc[(ti['pos'] == 'ANUM,APRO,S') & (~ti['morphemic_structure'].str.endswith('END')), 'morphemic_structure'] += '/Ø:END'

# Функции для замены символов
def replace_ending(row):
    if row['lemma'].endswith('ийся') and row['morphemic_structure'].endswith('/ий:SUFF/ся:POST'):
        return row['morphemic_structure'].replace('/ий:SUFF/ся:POST', '/ий:END/ся:POST')
    else:
        return row['morphemic_structure']

# Применение функции к датасету
ti['morphemic_structure'] = ti.apply(replace_ending, axis=1)

def replace_ending(row):
    if row['lemma'].endswith('ся') and row['morphemic_structure'].endswith('/ся:POST/Ø:END'):
        return row['morphemic_structure'].replace('/ся:POST/Ø:END', '/ся:POST')
    else:
        return row['morphemic_structure']

# Применение функции к датасету
ti['morphemic_structure'] = ti.apply(replace_ending, axis=1)

def replace_ending(row):
    if row['lemma'].endswith('тье') and row['morphemic_structure'].endswith('/ть:END/е:END'):
        return row['morphemic_structure'].replace('/ть:END/е:END', '/ть:SUFF/е:END')
    else:
        return row['morphemic_structure']

# Применение функции к датасету
ti['morphemic_structure'] = ti.apply(replace_ending, axis=1)

def replace_ending(row):
    if row['lemma'].endswith('либо') and row['morphemic_structure'].endswith('/либо:POST/Ø:END'):
        return row['morphemic_structure'].replace('/либо:POST/Ø:END', '/либо:POST')
    else:
        return row['morphemic_structure']

# Применение функции к датасету
ti['morphemic_structure'] = ti.apply(replace_ending, axis=1)

def replace_ending(row):
    if row['lemma'].endswith('нибудь') and row['morphemic_structure'].endswith('/нибудь:POST/Ø:END'):
        return row['morphemic_structure'].replace('/нибудь:POST/Ø:END', '/нибудь:POST')
    else:
        return row['morphemic_structure']

# Применение функции к датасету
ti['morphemic_structure'] = ti.apply(replace_ending, axis=1)

"""### Анализ состава датасета"""

# Функция для подсчета количества морфем
def count_slash(morphemic_structure):
    return morphemic_structure.count('/') + 1

# Применяем функцию к столбцу "morphemic_structure" и добавляем результат в новый столбец "morphema_count"
ti['morphema_count'] = ti['morphemic_structure'].apply(count_slash)

# Проверка
ti.head()

ti['morphema_count'].value_counts()

ti.query('morphema_count == 17')

# Процентное соотношение
percentages = df['morphema_count'].value_counts(normalize=True) * 100

# Круговая диаграмма
#fig = go.Figure(data=[go.Pie(labels=percentages.index, values=percentages.values, hole=.3, hoverinfo='label+percent')])
fig = go.Figure(data=[go.Pie(labels=percentages.index, values=percentages.values, customdata=percentages.values,
                             hovertemplate='%{label}: %{customdata:.1f}%', textinfo='label+percent', hole=0.3)])

# Заголовок
fig.update_layout(title_text="Распределение количества морфем в процентном соотношении")

# Отображение диаграммы
fig.show()

# Функция для подсчета количества приставок
def count_slash(morphemic_structure):
    return morphemic_structure.count('PREF')

# Применяем функцию к столбцу "morphemic_structure" и добавляем результат в новый столбец "pref_count"
ti['pref_count'] = ti['morphemic_structure'].apply(count_slash)

ti.head()

ti['pref_count'].value_counts()

# Процентное соотношение
percentages = ti['pref_count'].value_counts(normalize=True) * 100

# Круговая диаграмма
fig = go.Figure(data=[go.Pie(labels=percentages.index, values=percentages.values, customdata=percentages.values,
                             hovertemplate='%{label}: %{customdata:.1f}%', textinfo='label+percent', hole=0.3)])
# Заголовок
fig.update_layout(title_text="Распределение количества приставок в процентном соотношении")

# Отображение диаграммы
fig.show()

# Функция для подсчета количества корней
def count_slash(morphemic_structure):
    return morphemic_structure.count('ROOT')

# Применяем функцию к столбцу "morphemic_structure" и добавляем результат в новый столбец "root_count"
ti['root_count'] = ti['morphemic_structure'].apply(count_slash)

ti.head()

ti['root_count'].value_counts()

ti.query('root_count == 0')

df.query('pref_count == 2')

# Процентное соотношение
percentages = ti['root_count'].value_counts(normalize=True) * 100

# Круговая диаграмма
fig = go.Figure(data=[go.Pie(labels=percentages.index, values=percentages.values, customdata=percentages.values,
                             hovertemplate='%{label}: %{customdata:.1f}%', textinfo='label+percent', hole=0.3)])
# Заголовок
fig.update_layout(title_text="Распределение количества приставок в процентном соотношении")

# Отображение диаграммы
fig.show()

# Функция для подсчета количества суффиксов
def count_slash(morphemic_structure):
    return morphemic_structure.count('SUFF')

# Применяем функцию к столбцу "morphemic_structure" и добавляем результат в новый столбец "suff_count"
ti['suff_count'] = ti['morphemic_structure'].apply(count_slash)

ti.head()

ti['suff_count'].value_counts()

ti.query('suff_count == 7')

# Процентное соотношение
percentages = ti['suff_count'].value_counts(normalize=True) * 100

# Круговая диаграмма
fig = go.Figure(data=[go.Pie(labels=percentages.index, values=percentages.values, customdata=percentages.values,
                             hovertemplate='%{label}: %{customdata:.1f}%', textinfo='label+percent', hole=0.3)])
# Заголовок
fig.update_layout(title_text="Распределение количества приставок в процентном соотношении")

# Отображение диаграммы
fig.show()

# Функция для подсчета количества окончаний
def count_slash(morphemic_structure):
    return morphemic_structure.count('END')

# Применяем функцию к столбцу "morphemic_structure" и добавляем результат в новый столбец "end_count"
ti['end_count'] = ti['morphemic_structure'].apply(count_slash)

ti.head()

ti['end_count'].value_counts()

# Процентное соотношение
percentages = ti['end_count'].value_counts(normalize=True) * 100

# Круговая диаграмма
fig = go.Figure(data=[go.Pie(labels=percentages.index, values=percentages.values, customdata=percentages.values,
                             hovertemplate='%{label}: %{customdata:.1f}%', textinfo='label+percent', hole=0.3)])
# Заголовок
#fig.update_layout(title_text="Распределение количества приставок в процентном соотношении")

# Отображение диаграммы
fig.show()

# Функция для подсчета количества интерфиксов
def count_slash(morphemic_structure):
    return morphemic_structure.count('LINK')

# Применяем функцию к столбцу "morphemic_structure" и добавляем результат в новый столбец "link_count"
ti['link_count'] = ti['morphemic_structure'].apply(count_slash)

ti.head()

ti['link_count'].value_counts()

ti.query('link_count == 3')

# Процентное соотношение
percentages = ti['link_count'].value_counts(normalize=True) * 100

# Круговая диаграмма
fig = go.Figure(data=[go.Pie(labels=percentages.index, values=percentages.values, customdata=percentages.values,
                             hovertemplate='%{label}: %{customdata:.1f}%', textinfo='label+percent', hole=0.3)])
# Заголовок
fig.update_layout(title_text="Распределение количества приставок в процентном соотношении")

# Отображение диаграммы
fig.show()

# Функция для подсчета количества дефисов
def count_slash(morphemic_structure):
    return morphemic_structure.count('HYPN')

# Применяем функцию к столбцу "morphemic_structure" и добавляем результат в новый столбец "hypn_count"
ti['hypn_count'] = ti['morphemic_structure'].apply(count_slash)

ti.head()

ti['hypn_count'].value_counts()

# Процентное соотношение
percentages = ti['hypn_count'].value_counts(normalize=True) * 100

# Круговая диаграмма
fig = go.Figure(data=[go.Pie(labels=percentages.index, values=percentages.values, customdata=percentages.values,
                             hovertemplate='%{label}: %{customdata:.1f}%', textinfo='label+percent', hole=0.3)])
# Заголовок
#fig.update_layout(title_text="Распределение количества приставок в процентном соотношении")

# Отображение диаграммы
fig.show()

# Функция для подсчета количества постфиксов
def count_slash(morphemic_structure):
    return morphemic_structure.count('POST')

# Применяем функцию к столбцу "morphemic_structure" и добавляем результат в новый столбец "post_count"
ti['post_count'] = ti['morphemic_structure'].apply(count_slash)

ti.head()

ti['post_count'].value_counts()

# Процентное соотношение
percentages = ti['post_count'].value_counts(normalize=True) * 100

# Круговая диаграмма
fig = go.Figure(data=[go.Pie(labels=percentages.index, values=percentages.values, customdata=percentages.values,
                             hovertemplate='%{label}: %{customdata:.1f}%', textinfo='label+percent', hole=0.3)])
# Заголовок
fig.update_layout(title_text="Распределение количества приставок в процентном соотношении")

# Отображение диаграммы
fig.show()

ti.to_csv('tikhonov.csv')

"""### Анализ уникальных морфем"""

# Получение уникальных морфем
unique_morphemic_structures = set()

for structure in data['morphemic_structure']:
    unique_morphemic_structures.update(structure.split('/'))

# Вывод уникальных морфем
print("Уникальные морфемные структуры:")
print(unique_morphemic_structures)

vocab_size = len(unique_morphemic_structures)
print("Размер словаря:", vocab_size)

# Создание отдельного датасета
df = pd.DataFrame({'morphemic_structure': unique_morphemic_structures})

# Вывод фрагмента датасета
df.head()

# Разделение столбца на два
df[['morphema', 'status']] = df['morphemic_structure'].str.split(':', expand=True)

# Вывод фрагмента датасета
df.head()

df['status'].value_counts()

df.query('status == "END"')

# Получение количества уникальных значений и их частоты в столбце 'status'
status_counts = df['status'].value_counts()

# Создание датасета для построения круговой диаграммы
status_df = pd.DataFrame({'status': status_counts.index, 'count': status_counts.values})

# Круговая диаграмма
fig = px.pie(status_df, values='count', names='status')
fig.show()